/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include <GTM_Motor_PWM.h>
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "Blinky_LED.h"
#include "Driver_Stm.h"
#include "ADC_Background_Scan.h"

#include "Bsp.h"

#include <stdio.h>




#define DIR_B       &MODULE_P10,2
#define PWM_B       &MODULE_P10,3
#define BREAK_B     &MODULE_P02,6


IfxCpu_syncEvent g_cpuSyncEvent = 0;

/*Variable*/
/***********************************************************************/
//uint32 ULSraw;
boolean ENCA;
boolean ENCB;
boolean ENCA_old;
boolean ENCB_old;
//uint32 trig_A;
//uint32 trig_B;
//boolean intr_A;
//boolean intr_B;
//float32 duty[2];
//float32 Vin;
int S;
int S_old;
int PosCnt = 0;
int PosCntd = 0;
float32 Direction;
float32 Pos_rad;
//float32 ome_d;
//float32 Pos_rad_d;
int Pos_deg;
//extern float32 theta;
//extern float32 theta_old;
//float32 theta_d_old;
//float32 w = 0;
//float32 Wd;
//float32 w_old = 0;
//float32 error_w = 0;
//uint32 W_RPM;
//float32 w_ref;
//uint32 ACnt;
//float32 error_w_int_old;
//float32 error_w_int;
//float32 du_w;
//float32 kp = 0.5;
//float32 ki = 0.5;
//float32 t;
//float32 per;
//float32 per_old;
//float32 W_st;
//float32 V_st;
/***********************************************************************/
/*Function*/
/***********************************************************************/

extern uint32 W_RPM;
extern float32 w;

boolean front_ENCA;
boolean front_ENCB;
boolean front_ENCA_old;
boolean front_ENCB_old;

boolean rear_ENCA;
boolean rear_ENCB;
boolean rear_ENCA_old;
boolean rear_ENCB_old;

int front_S;
int front_S_old;
int rear_S;
int rear_S_old;
int front_PosCnt = 0;
int front_PosCntd = 0;
int rear_PosCnt = 0;
int rear_PosCntd = 0;
int front_Pos_deg;
extern float32 front_theta;
int rear_Pos_deg;
extern float32 rear_theta;
float32 front_Pos_rad;
float32 rear_Pos_rad;


static void AppNoTask (void)
{
//    IfxPort_setPinModeInput(IfxPort_P02_1.port, IfxPort_P02_1.pinIndex, IfxPort_InputMode_pullDown); // 0630 Hall digital input mode //  pull down: input 3.3V -> High (1) // 0726 -> QEP PULSE LOGIC
//    IfxPort_setPinModeInput(IfxPort_P02_0.port, IfxPort_P02_0.pinIndex, IfxPort_InputMode_pullDown); // 0630 Hall digital input mode
//    ENCA = IfxPort_getPinState(ENCODER_A); // Encoder A signal state
//    ENCB = IfxPort_getPinState(ENCODER_B); // Encoder B signal state
//
//    if (ENCA == FALSE && ENCB == FALSE)
//    {
//        S = 0;
//    }
//    else if (ENCA == FALSE && ENCB == TRUE)
//    {
//        S = 1;
//    }
//    else if (ENCA == TRUE && ENCB == TRUE)
//    {
//        S = 2;
//    }
//    else if (ENCA == TRUE && ENCB == FALSE)
//    {
//        S = 3;
//    }
//
//    // ���� ȸ�� ���� Ȯ��
//    // S�� �����ϸ� ������ direction = 1
//    // S�� �����ϸ� ������ direction = 0
//    if (S - S_old == 1 || S - S_old == -3)
//    {
//        PosCnt = PosCntd - 1;
//        Direction = 1;
//    }
//    else if (S - S_old == -1 || S - S_old == 3)
//    {
//        PosCnt = PosCntd + 1;
//        Direction = -1;
//    }
//
//
//
//    S_old = S;
//
//    ENCA_old = ENCA;
//    ENCB_old = ENCB;
//    Pos_rad = PosCnt * 2 * 3.14159265358979323846264 / 48;
//    Pos_deg = (int) (PosCnt * 360 / 48);
//    theta = Pos_rad;
//
//    PosCntd = PosCnt;


    front_ENCA = IfxPort_getPinState(FRONT_ENCODER_A); // Encoder A signal state
    front_ENCB = IfxPort_getPinState(FRONT_ENCODER_B); // Encoder B signal state

    rear_ENCA = IfxPort_getPinState(REAR_ENCODER_A); // Encoder A signal state
    rear_ENCB = IfxPort_getPinState(REAR_ENCODER_B); // Encoder B signal state


    if (front_ENCA == FALSE && front_ENCB == FALSE)
    {
        front_S = 0;
    }
    else if (front_ENCA == FALSE && front_ENCB == TRUE)
    {
        front_S = 1;
    }
    else if (front_ENCA == TRUE && front_ENCB == TRUE)
    {
        front_S = 2;
    }
    else if (front_ENCA == TRUE && front_ENCB == FALSE)
    {
        front_S = 3;
    }

    if (rear_ENCA == FALSE && rear_ENCB == FALSE)
    {
        rear_S = 0;
    }
    else if (rear_ENCA == FALSE && rear_ENCB == TRUE)
    {
        rear_S = 1;
    }
    else if (rear_ENCA == TRUE && rear_ENCB == TRUE)
    {
        rear_S = 2;
    }
    else if (rear_ENCA == TRUE && rear_ENCB == FALSE)
    {
        rear_S = 3;
    }

    // ���� ȸ�� ���� Ȯ��
    // S�� �����ϸ� ������ direction = 1
    // S�� �����ϸ� ������ direction = 0
    if (front_S - front_S_old == 1 || front_S - front_S_old == -3)
    {
        front_PosCnt = front_PosCntd - 1;
//        Direction = 1;
    }
    else if (front_S - front_S_old == -1 || front_S - front_S_old == 3)
    {
        front_PosCnt = front_PosCntd + 1;
//        Direction = -1;
    }

    if (rear_S - rear_S_old == 1 || rear_S - rear_S_old == -3)
    {
        rear_PosCnt = rear_PosCntd - 1;
//        Direction = 1;
    }
    else if (rear_S - rear_S_old == -1 || rear_S - rear_S_old == 3)
    {
        rear_PosCnt = rear_PosCntd + 1;
//        Direction = -1;
    }

    front_S_old = front_S;
    rear_S_old=rear_S;

    front_ENCA_old = front_ENCA;
    front_ENCB_old = front_ENCB;
    front_Pos_rad = front_PosCnt * 2 * 3.14159265358979323846264 / 48;
    front_Pos_deg = (int) (front_PosCnt * 360 / 48);
    front_theta = front_Pos_rad;

    rear_ENCA_old = rear_ENCA;
    rear_ENCB_old = rear_ENCB;
    rear_Pos_rad = rear_PosCnt * 2 * 3.14159265358979323846264 / 48;
    rear_Pos_deg = (int) (rear_PosCnt * 360 / 48);
    rear_theta = rear_Pos_rad;

    if(front_PosCntd!=front_PosCnt){
        printf("front_ENCA: %d\n",front_ENCA);
        printf("front_ENCB: %d\n", front_ENCB);
        printf("front_S: %d\n",front_S);
        printf("front_PosCnt: %d\n",front_PosCnt);
        printf("\n");
    }
    if (rear_PosCntd != rear_PosCnt){
        printf("rear_ENCA: %d\n", front_ENCA);
        printf("rear_ENCB: %d\n", rear_ENCB);
        printf("rear_S: %d\n", front_S);
        printf("rear_PosCnt: %d\n", rear_PosCnt);
        printf("\n");
    }

    front_PosCntd = front_PosCnt;
    rear_PosCntd= rear_PosCnt;
}

int core0_main (void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    //initADC();
//    Driver_Stm_Init();
//    initGtmTomPwm();

//    uint16 delay;

    initMotor();

//    setMotorDutyCycle_A(PWM_PERIOD);
//    setMotorDutyCycle_B(PWM_PERIOD);

    IfxPort_setPinLow(PWM_A);
    IfxPort_setPinLow(PWM_B);



    while (1)
    {

//        delay=readADCValue(7);
//        delay=(uint16)(((double)delay/((1<<12)-1))*500);

//        wait(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, delay));
////
//        fadeMotor();
//        wait(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, 10));
//        AppNoTask();
    }
    return (1);
}
